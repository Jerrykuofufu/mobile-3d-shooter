<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Gravity Courier Run</title>
  <style>
    :root{
      --bg1:#e7f2ff;
      --bg2:#f7f9ff;
      --ink:#0b1020;
      --muted:#56607a;
      --card:rgba(255,255,255,.72);
      --stroke:rgba(10,20,40,.14);

      --neo1:#7cf7ff;
      --neo2:#9d7bff;
      --neo3:#ff5bd6;
      --neo4:#7bffb1;
    }
    html,body{
      margin:0;padding:0;
      background: radial-gradient(1200px 600px at 30% 0%, var(--bg1), var(--bg2));
      color:var(--ink);
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", Arial;
      overflow-x:hidden;
    }
    .wrap{max-width:980px;margin:14px auto;padding:0 12px;}
    h1{margin:8px 0 8px;font-size:40px;letter-spacing:.5px;line-height:1.05}
    .subbar{
      display:flex;gap:10px;flex-wrap:wrap;align-items:center;
      margin:6px 0 10px;
    }
    .pill{
      background:rgba(255,255,255,.7);
      border:1px solid var(--stroke);
      backdrop-filter: blur(10px);
      border-radius:999px;
      padding:8px 12px;
      color:var(--muted);
      font-size:14px;
      box-shadow: 0 10px 30px rgba(10,20,40,.10);
    }
    .pill b{color:var(--ink)}
    .panel{
      background:var(--card);
      border:1px solid var(--stroke);
      border-radius:18px;
      box-shadow: 0 18px 40px rgba(10,20,40,.12);
      padding:14px;
    }

    /* ===== Neon Frame ===== */
    .frameWrap{position:relative;border-radius:22px;padding:10px}
    .frameGlow{
      position:absolute;inset:-10px;
      background: conic-gradient(from 120deg, var(--neo1), var(--neo2), var(--neo3), var(--neo4), var(--neo1));
      filter: blur(20px);
      opacity:.55;
      border-radius:28px;
      animation: spin 10s linear infinite;
    }
    .frame{
      position:relative;
      border-radius:18px;
      padding:10px;
      background: rgba(255,255,255,.70);
      border:2px solid rgba(255,255,255,.65);
      box-shadow:
        0 0 0 2px rgba(10,20,40,.10) inset,
        0 18px 40px rgba(10,20,40,.15);
    }
    @keyframes spin{to{transform:rotate(360deg)}}

    canvas{
      width:100%;
      height:auto;
      display:block;
      border-radius:14px;
      background: linear-gradient(180deg, rgba(255,255,255,.75), rgba(255,255,255,.65));
      box-shadow: 0 0 0 2px rgba(10,20,40,.08) inset;
      touch-action: manipulation;
    }
    .bar{display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin-top:10px}
    .stats{display:flex;flex-wrap:wrap;gap:14px;align-items:center}
    .stats span{color:var(--muted)}
    .stats b{color:var(--ink)}
    .btns{display:flex;flex-wrap:wrap;gap:10px;margin-left:auto}
    button{
      border:2px dashed rgba(10,20,40,.25);
      background:rgba(255,255,255,.9);
      color:var(--ink);
      padding:10px 14px;
      border-radius:14px;
      font-weight:800;
      font-size:15px;
    }
    button.primary{
      border-style:solid;
      border-color: rgba(80,140,255,.55);
      box-shadow: 0 12px 26px rgba(80,140,255,.22);
    }
    button:active{transform:translateY(1px)}
    input{
      border:1px solid rgba(10,20,40,.2);
      background:rgba(255,255,255,.85);
      border-radius:14px;
      padding:10px 12px;
      font-size:15px;
      outline:none;
      min-width:170px;
    }
    .tip{
      color:var(--muted);
      font-size:14px;
      margin-top:10px;
    }
    .tip b{color:var(--ink)}
    .hintSmall{font-size:12px;opacity:.85}
    .rightChip{
      margin-left:auto;
      background:rgba(255,255,255,.75);
      border:1px solid var(--stroke);
      border-radius:999px;
      padding:8px 12px;
      color:var(--muted);
      font-size:13px;
      box-shadow: 0 10px 30px rgba(10,20,40,.08);
      max-width: 320px;
    }

    @media (max-width:540px){
      h1{font-size:34px}
      .rightChip{max-width:100%}
      .btns{margin-left:0;width:100%}
      .btns button{flex:1}
      input{flex:1;min-width:0;width:100%}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div style="display:flex;gap:10px;align-items:flex-start;flex-wrap:wrap">
      <h1>ğŸ›µ Gravity Courier Run</h1>
      <div class="rightChip"><b>é»ä¸€ä¸‹ç¿»è½‰é‡åŠ›</b>ï½œæ‰‹æ©Ÿè¶…é †ï½œCombo è¶Šé«˜åŠ åˆ†è¶Šé¦™ ğŸ•</div>
    </div>

    <div class="subbar">
      <div class="pill">æ“ä½œï¼š<b>é»ä¸€ä¸‹ / ç©ºç™½éµ</b>ï¼é‡åŠ›ç¿»è½‰ï¼ˆåœ°æ¿â‡„å¤©èŠ±æ¿ï¼‰</div>
      <div class="pill">å°æŠ€å·§ï¼šè²¼è‘—éšœç¤™é£›è¶Šï¼ˆåˆ¥æ’åˆ°ï¼‰æ›´å®¹æ˜“ç´¯ç© <b>Combo</b></div>
    </div>

    <div class="panel">
      <div class="frameWrap">
        <div class="frameGlow"></div>
        <div class="frame">
          <canvas id="cv" width="900" height="360"></canvas>
        </div>
      </div>

      <div class="bar">
        <div class="stats">
          <span>Score: <b id="score">0</b></span>
          <span>Best: <b id="best">0</b></span>
          <span>Combo: <b id="combo">0</b></span>
          <span>Speed: <b id="spd">1.0</b></span>
        </div>

        <div class="btns">
          <input id="name" maxlength="12" placeholder="Name (â‰¤12)" />
          <button id="restart" class="primary">é‡æ–°é–‹å§‹</button>
          <button id="sfx">SFX: ON</button>
          <button id="bgm">BGM: OFF</button>
        </div>
      </div>

      <div class="tip">
        <b>ç©æ³•ï¼š</b>é»ä¸€ä¸‹å°±æŠŠé‡åŠ›ç¿»éå»ï¼Œé¿é–‹æŸ±å­ï¼<span class="hintSmall">ï¼ˆæ‰‹æ©Ÿç¬¬ä¸€æ¬¡é»ç•«é¢å¾Œæ‰å…è¨±æ’­æ”¾è²éŸ³ï¼Œé€™æ˜¯ç€è¦½å™¨è¦å‰‡ï¼‰</span>
        <br/>
        <span class="hintSmall">æç¤ºï¼šé‡æ–°é–‹å§‹å¾Œæœƒå…ˆã€Œå¾…æ©Ÿã€ï¼Œå†é»ä¸€ä¸‹æ‰é–‹å§‹è·‘ï¼ˆä¸æœƒç§’é–‹ï¼‰ğŸ˜º</span>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== Canvas =====
  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d", { alpha: false });

  // ===== UI =====
  const scoreEl = document.getElementById("score");
  const bestEl  = document.getElementById("best");
  const comboEl = document.getElementById("combo");
  const spdEl   = document.getElementById("spd");
  const restartBtn = document.getElementById("restart");
  const sfxBtn = document.getElementById("sfx");
  const bgmBtn = document.getElementById("bgm");
  const nameEl = document.getElementById("name");

  // ===== Storage =====
  const bestKey = "gcr_best";
  const nameKey = "gcr_name";
  let best = +(localStorage.getItem(bestKey) || 0);
  bestEl.textContent = best;
  nameEl.value = (localStorage.getItem(nameKey) || "Milo").slice(0,12);

  nameEl.addEventListener("input", () => {
    localStorage.setItem(nameKey, (nameEl.value || "Milo").trim().slice(0,12));
  });

  // ===== Audio (simple synth) =====
  let audioCtx = null;
  let sfxOn = true;
  let bgmOn = false;
  let bgmTimer = null;

  function unlockAudio(){
    if (!audioCtx){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (audioCtx.state === "suspended") audioCtx.resume();
  }

  function beep(freq=440, dur=0.06, type="sine", vol=0.12){
    if(!sfxOn || !audioCtx) return;
    const t0 = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.setValueAtTime(freq, t0);
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.exponentialRampToValueAtTime(vol, t0 + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
    o.connect(g).connect(audioCtx.destination);
    o.start(t0);
    o.stop(t0 + dur + 0.02);
  }

  function startBGM(){
    if(!bgmOn || !audioCtx) return;
    stopBGM();
    const seq = [
      [392, 0.09],[440, 0.09],[523.25,0.09],[440,0.09],
      [392, 0.09],[349.23,0.09],[392,0.12],[0,0.10],
    ];
    let i=0;
    bgmTimer = setInterval(() => {
      const [f, d] = seq[i++ % seq.length];
      if(f>0) beep(f, d, "triangle", 0.05);
    }, 120);
  }
  function stopBGM(){
    if(bgmTimer){ clearInterval(bgmTimer); bgmTimer=null; }
  }

  sfxBtn.addEventListener("click", () => {
    unlockAudio();
    sfxOn = !sfxOn;
    sfxBtn.textContent = `SFX: ${sfxOn ? "ON" : "OFF"}`;
    if(sfxOn) beep(660,0.05,"square",0.08);
  });
  bgmBtn.addEventListener("click", () => {
    unlockAudio();
    bgmOn = !bgmOn;
    bgmBtn.textContent = `BGM: ${bgmOn ? "ON" : "OFF"}`;
    if(bgmOn) startBGM(); else stopBGM();
  });

  // ===== Game State =====
  const W = cv.width, H = cv.height;
  const floorY = H - 70;
  const ceilY  = 70;

  let running = false;     // true = loop updates
  let playing = false;     // true = actually moving obstacles & scoring
  let lastT = 0;

  let score = 0;
  let combo = 0;
  let speed = 260;         // pixels per second (base)
  let speedMul = 1;

  const player = {
    x: 120,
    y: floorY - 26,
    w: 22,
    h: 26,
    vy: 0,
    g: 1400,
    gravSign: +1, // +1 gravity down, -1 gravity up
    onSurface: true,
    flipCD: 0
  };

  const obstacles = [];
  const clouds = [];
  let spawnTimer = 0;

  // visual scene
  let scenePhase = 0;

  function reset(){
    running = true;
    playing = false; // start in standby (won't move until first tap)
    score = 0;
    combo = 0;
    speedMul = 1;
    spawnTimer = 0;
    obstacles.length = 0;
    clouds.length = 0;
    scenePhase = 0;

    player.gravSign = +1;
    player.y = floorY - player.h;
    player.vy = 0;
    player.onSurface = true;
    player.flipCD = 0;

    for(let i=0;i<6;i++){
      clouds.push({
        x: Math.random()*W,
        y: 30 + Math.random()*120,
        s: 16 + Math.random()*26,
        vx: 8 + Math.random()*18
      });
    }

    scoreEl.textContent = "0";
    comboEl.textContent = "0";
    spdEl.textContent = "1.0";
  }

  function startPlay(){
    if(!running) return;
    if(playing) return;
    playing = true;
    unlockAudio();
    if(bgmOn) startBGM();
  }

  function gameOver(){
    playing = false;
    // keep standby, not frozen UI
    if(score > best){
      best = score;
      localStorage.setItem(bestKey, best);
      bestEl.textContent = best;
    }
    beep(180,0.12,"sawtooth",0.10);
    beep(120,0.16,"sine",0.10);
  }

  function flipGravity(){
    if(!running) return;
    startPlay();

    if(player.flipCD > 0) return;

    // Flip
    player.gravSign *= -1;
    // give a small impulse in the new gravity direction for responsiveness
    player.vy = -player.gravSign * 520;

    // SFX
    beep(880,0.04,"square",0.08);
    beep(660,0.06,"triangle",0.06);

    player.onSurface = false;
    player.flipCD = 0.12; // prevent double flip spam
  }

  // input
  function onTap(e){
    e.preventDefault?.();
    unlockAudio();
    flipGravity();
  }
  cv.addEventListener("pointerdown", onTap, { passive:false });
  window.addEventListener("keydown", (e) => {
    if(e.code === "Space"){
      e.preventDefault();
      unlockAudio();
      flipGravity();
    }
  }, { passive:false });

  restartBtn.addEventListener("click", () => {
    unlockAudio();
    reset();
    // IMPORTANT: not auto play. wait for first tap/space
  });

  // ===== Spawning =====
  function spawnObstacle(){
    // gap size changes with speed but keeps fair
    const minGap = 180;
    const maxGap = 260;

    const gap = minGap + (maxGap-minGap) * Math.random();

    // obstacle width
    const w = 18 + Math.random()*16;
    // obstacle height varies
    const h = 34 + Math.random()*90;

    // choose floor or ceiling obstacle
    const fromFloor = Math.random() < 0.5;

    const o = {
      x: W + 40,
      w,
      h,
      fromFloor,
      passed:false
    };
    obstacles.push(o);

    // timer until next
    spawnTimer = gap / (speed*speedMul);
  }

  function rectHit(ax,ay,aw,ah,bx,by,bw,bh){
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  // ===== Update / Draw =====
  function update(dt){
    // clouds always drift even in standby
    for(const c of clouds){
      c.x -= c.vx * dt;
      if(c.x < -60){ c.x = W + 60; c.y = 30 + Math.random()*120; }
    }

    if(!playing){
      // only idle bob
      player.flipCD = Math.max(0, player.flipCD - dt);
      return;
    }

    // speed ramps
    speedMul = Math.min(2.2, 1 + score/900);
    spdEl.textContent = speedMul.toFixed(1);

    // score
    score += Math.floor(60 * dt * speedMul);
    scoreEl.textContent = score;

    // scene phase
    scenePhase = Math.floor(score / 800) % 3;

    // physics
    player.flipCD = Math.max(0, player.flipCD - dt);

    player.vy += player.g * player.gravSign * dt;
    player.y  += player.vy * dt;

    // surface collide
    if(player.gravSign > 0){
      // floor
      const targetY = floorY - player.h;
      if(player.y > targetY){
        player.y = targetY;
        player.vy = 0;
        player.onSurface = true;
      } else player.onSurface = false;
    } else {
      // ceiling
      const targetY = ceilY;
      if(player.y < targetY){
        player.y = targetY;
        player.vy = 0;
        player.onSurface = true;
      } else player.onSurface = false;
    }

    // spawn
    spawnTimer -= dt;
    if(spawnTimer <= 0){
      spawnObstacle();
    }

    // move obstacles
    const vx = speed * speedMul;
    for(const o of obstacles){
      o.x -= vx * dt;
      // scoring pass
      if(!o.passed && o.x + o.w < player.x){
        o.passed = true;
        score += 10; // base pass bonus
        // combo: if close to obstacle edge (skill)
        const pyMid = player.y + player.h/2;
        const oTop = o.fromFloor ? (floorY - o.h) : ceilY;
        const oBot = o.fromFloor ? floorY : (ceilY + o.h);

        // "close fly" when within 18px margin
        const margin = 18;
        const close = (Math.abs(pyMid - oTop) < margin) || (Math.abs(pyMid - oBot) < margin);
        if(close){
          combo++;
          score += 8 * combo;
          beep(740 + combo*20, 0.04, "triangle", 0.06);
        }else{
          combo = 0;
        }
        comboEl.textContent = combo;
      }

      // collision
      const oy = o.fromFloor ? (floorY - o.h) : ceilY;
      if(rectHit(player.x, player.y, player.w, player.h, o.x, oy, o.w, o.h)){
        gameOver();
      }
    }

    // clean
    while(obstacles.length && obstacles[0].x < -80){
      obstacles.shift();
    }
  }

  function drawBackground(){
    // scene tint
    let sky1, sky2, line;
    if(scenePhase === 0){
      sky1 = "#f6fbff"; sky2="#e9f2ff"; line="rgba(40,80,140,.22)";
    } else if(scenePhase === 1){
      sky1 = "#fdf7ff"; sky2="#e8e2ff"; line="rgba(90,60,160,.22)";
    } else {
      sky1 = "#0b1020"; sky2="#121b34"; line="rgba(170,220,255,.12)";
    }

    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, sky1);
    g.addColorStop(1, sky2);
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // clouds / stars
    if(scenePhase !== 2){
      ctx.fillStyle = "rgba(255,255,255,.75)";
      for(const c of clouds){
        ctx.beginPath();
        ctx.ellipse(c.x, c.y, c.s*1.2, c.s*0.8, 0, 0, Math.PI*2);
        ctx.ellipse(c.x+18, c.y+6, c.s*0.9, c.s*0.7, 0, 0, Math.PI*2);
        ctx.ellipse(c.x-18, c.y+8, c.s*0.85, c.s*0.65, 0, 0, Math.PI*2);
        ctx.fill();
      }
    } else {
      // stars
      ctx.fillStyle = "rgba(255,255,255,.8)";
      for(let i=0;i<80;i++){
        const x = (i*97)%W;
        const y = (i*53)%H;
        ctx.fillRect(x, y, 1, 1);
      }
    }

    // floor & ceiling rails
    ctx.strokeStyle = line;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, floorY+2); ctx.lineTo(W, floorY+2);
    ctx.moveTo(0, ceilY-2);  ctx.lineTo(W, ceilY-2);
    ctx.stroke();

    // dotted guide
    ctx.strokeStyle = "rgba(0,0,0,.08)";
    ctx.setLineDash([6,10]);
    ctx.beginPath();
    ctx.moveTo(0, (floorY+ceilY)/2); ctx.lineTo(W, (floorY+ceilY)/2);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  function drawObstacle(o){
    const y = o.fromFloor ? (floorY - o.h) : ceilY;
    // neon-ish obstacle
    ctx.save();
    ctx.shadowColor = "rgba(125,250,255,.45)";
    ctx.shadowBlur = 12;
    ctx.fillStyle = "rgba(20,30,50,.95)";
    ctx.fillRect(o.x, y, o.w, o.h);

    ctx.shadowBlur = 0;
    ctx.strokeStyle = "rgba(124,247,255,.55)";
    ctx.lineWidth = 2;
    ctx.strokeRect(o.x+1, y+1, o.w-2, o.h-2);
    ctx.restore();
  }

  function drawPlayer(){
    // small courier blob
    ctx.save();
    ctx.shadowColor = "rgba(255,90,210,.35)";
    ctx.shadowBlur = 10;

    // body
    ctx.fillStyle = "rgba(10,20,40,.95)";
    ctx.fillRect(player.x, player.y, player.w, player.h);

    // visor
    ctx.shadowBlur = 0;
    ctx.fillStyle = "rgba(124,247,255,.85)";
    ctx.fillRect(player.x+4, player.y+6, player.w-8, 6);

    // tiny wheel/foot
    ctx.fillStyle = "rgba(255,255,255,.9)";
    const footY = player.gravSign>0 ? (player.y+player.h-4) : (player.y+2);
    ctx.fillRect(player.x+6, footY, player.w-12, 2);

    ctx.restore();
  }

  function drawHUD(){
    if(!playing){
      // standby text
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,.35)";
      ctx.font = "800 44px ui-sans-serif, system-ui";
      ctx.textAlign = "center";
      ctx.fillText("TAP TO START", W/2, H/2 - 10);
      ctx.font = "600 16px ui-sans-serif, system-ui";
      ctx.fillStyle = "rgba(0,0,0,.30)";
      ctx.fillText("é»ä¸€ä¸‹ / ç©ºç™½éµ é–‹å§‹ä¸¦ç¿»è½‰é‡åŠ›", W/2, H/2 + 22);
      ctx.restore();
    }
    if(!playing && score>0){
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,.18)";
      ctx.font = "900 56px ui-sans-serif, system-ui";
      ctx.textAlign = "center";
      ctx.fillText("GAME OVER", W/2, H/2 - 70);
      ctx.restore();
    }
  }

  function draw(){
    drawBackground();
    // obstacles
    for(const o of obstacles) drawObstacle(o);
    // player
    drawPlayer();
    // overlay text
    drawHUD();
  }

  // ===== Loop =====
  function loop(t){
    if(!running) return;
    if(!lastT) lastT = t;
    const dt = Math.min(0.033, (t - lastT) / 1000);
    lastT = t;

    update(dt);
    draw();

    requestAnimationFrame(loop);
  }

  // ===== Boot =====
  reset();
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
